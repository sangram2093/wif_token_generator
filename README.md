
# üõ°Ô∏è Secure Token API with Mutual TLS (mTLS)

This guide provides a complete, end-to-end setup of a secure **token delivery API** using **mutual TLS (mTLS)** between a Linux server and an application team client machine.

---

## üîß Directory Structure

Recommended folder (on both server and client):

```
/opt/wif-token-api/
‚îÇ
‚îú‚îÄ‚îÄ app.py                    # Flask server code
‚îú‚îÄ‚îÄ server.crt                # Server certificate (PEM)
‚îú‚îÄ‚îÄ server.key                # Server private key (unencrypted PEM)
‚îú‚îÄ‚îÄ client.crt                # Client certificate (PEM)
‚îú‚îÄ‚îÄ client.key                # Client private key
‚îú‚îÄ‚îÄ ca-chain.crt              # CA chain (Intermediate + Root)
‚îî‚îÄ‚îÄ wif_token.txt             # Token file generated by WIF project
```

---

## üîµ PART 1 ‚Äî Linux Server Setup (Flask API with mTLS)

### ‚úÖ Step 1: Create `ca-chain.crt` for validating client certs

```bash
cat intermediate.crt root-ca.crt > ca-chain.crt
```

### ‚úÖ Step 2: Decrypt your server private key (if needed)

```bash
openssl rsa -in server.key -out server-decrypted.key
# Use server-decrypted.key in Flask
```

---

### ‚úÖ Step 3: `app.py` ‚Äì Secure Flask API

```python
import os
from flask import Flask, jsonify

app = Flask(__name__)
WIF_HOME = os.environ.get("WIF_HOME", "/opt/wif-token-api")
WIF_TOKEN_FILENAME = os.path.join(WIF_HOME, "wif_token.txt")

@app.route("/")
def health_check():
    return jsonify({"status": "OK"}), 200

@app.route("/get_wif_token")
def get_token():
    try:
        with open(WIF_TOKEN_FILENAME, 'r') as f:
            token = f.read().strip()
            return jsonify({"access_token": token})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    import ssl
    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(certfile="server.crt", keyfile="server.key")  # Or server-decrypted.key
    context.load_verify_locations(cafile="ca-chain.crt")
    context.verify_mode = ssl.CERT_REQUIRED
    app.run(host="0.0.0.0", port=7001, ssl_context=context)
```

### ‚úÖ Step 4: Run the server

```bash
export WIF_HOME=/opt/wif-token-api
python3 app.py
```

API available at: `https://<server-host>:7001/get_wif_token`

---

## üü¢ PART 2 ‚Äî Application Team: Secure Client Access

### ‚úÖ Step 1: Generate client private key and CSR

```bash
openssl genrsa -out client.key 2048

openssl req -new -key client.key -out client.csr -subj "/CN=app-team-client/O=Internal/CD=cd/DC=com"
```

### ‚úÖ Step 2: Upload CSR to internal PKI and download `client.crt`

Request **TLS client authentication**. Download `client.crt`.

### ‚úÖ Step 3: Verify key pair

```bash
openssl x509 -noout -modulus -in client.crt | openssl md5
openssl rsa  -noout -modulus -in client.key  | openssl md5
```

‚úÖ Hashes must match.

### ‚úÖ Step 4: Create `ca-chain.crt` (same as server)

```bash
cat intermediate.crt root-ca.crt > ca-chain.crt
```

---

### ‚úÖ Step 5: Python Client Script

```python
import requests
import os

WIF_HOME = os.environ.get("WIF_HOME", "/tmp/wif")
WIF_TOKEN_FILENAME = os.path.join(WIF_HOME, "wif_token.txt")
endpoint_url = "https://<server-host>:7001/get_wif_token"

client_cert = ("client.crt", "client.key")  # or use a combined client.pem
ca_cert = "ca-chain.crt"

def get_token_from_endpoint():
    try:
        response = requests.get(endpoint_url, cert=client_cert, verify=ca_cert)
        response.raise_for_status()
        return response.json().get("access_token", None)
    except requests.exceptions.SSLError as ssl_err:
        print(f"‚ùå SSL error: {ssl_err}")
    except requests.exceptions.RequestException as req_err:
        print(f"‚ùå Request failed: {req_err}")
    return None

def write_token(filepath, content):
    if content:
        os.makedirs(os.path.dirname(filepath), exist_ok=True)
        with open(filepath, 'w') as f:
            f.write(content)
        print(f"‚úÖ Token written to {filepath}")
    else:
        print("‚ö†Ô∏è No token received.")

if __name__ == "__main__":
    token = get_token_from_endpoint()
    write_token(WIF_TOKEN_FILENAME, token)
```

---

## üß™ Optional: Test with curl

```bash
curl --cert client.crt --key client.key --cacert ca-chain.crt   https://<server-host>:7001/get_wif_token
```

---

## ‚úÖ Certificate Summary

| File            | Description                           |
|-----------------|----------------------------------------|
| `server.crt`    | Flask API server certificate (PEM)     |
| `server.key`    | Flask private key (unencrypted)        |
| `client.crt`    | App team client certificate            |
| `client.key`    | Client's private key                   |
| `ca-chain.crt`  | Combined root + intermediate certs     |

---

## üìç Expected Outcome

‚úÖ Only authorized app teams (with a signed certificate from internal PKI) will be able to securely fetch short-lived WIF tokens using `https://<server>/get_wif_token` over **mutual TLS**.
